# syntax=docker/dockerfile:1.7

# Cross-Platform Build Support:
# - For x86-64 (current): docker build --platform linux/amd64 ...
# - For ARM64: docker build --platform linux/arm64 ...
# Platform is specified via GitHub Actions buildx configuration

# ============================================================================
# Stage 1: Import UV binary from official image
# ============================================================================
FROM ghcr.io/astral-sh/uv:0.9.26 AS uv

# ============================================================================
# Stage 2: Builder stage - Install dependencies
# ============================================================================
FROM public.ecr.aws/lambda/python:3.12 AS builder

# UV environment variables for optimal performance
# - UV_COMPILE_BYTECODE=1: Precompile bytecode (faster cold starts)
# - UV_NO_INSTALLER_METADATA=1: Deterministic layers (smaller image)
# - UV_LINK_MODE=copy: Cache mount compatibility
ENV UV_COMPILE_BYTECODE=1 \
    UV_NO_INSTALLER_METADATA=1 \
    UV_LINK_MODE=copy

# Install system dependencies
# Note: tesseract removed for Lambda - OCR can be added via Lambda layers
# To add tesseract:
#   1. Use pre-built layer (recommended): See LAMBDA_LAYERS.md
#   2. Build custom layer: Run ./build-tesseract-layer.sh
#   3. Add layer ARN to Lambda function configuration
RUN dnf install -y \
    poppler-utils \
    gcc \
    gcc-c++ \
    && dnf clean all

# Copy requirements.txt FIRST (layer caching optimization)
# This ensures package installations are cached separately from code changes
COPY requirements.txt .

# Install Python dependencies with UV + BuildKit cache mount
# - UV is 10-100x faster than pip for large dependency sets
# - Cache mount preserves downloads across builds (5-day retention in GitHub Actions)
# - Packages install to LAMBDA_TASK_ROOT for Lambda compatibility
RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

# Download NLTK data to lambda task root
RUN python -m nltk.downloader punkt averaged_perceptron_tagger -d ${LAMBDA_TASK_ROOT}/nltk_data

# Copy application code AFTER dependencies
# This ensures code changes don't invalidate the package cache layer
COPY app/ ${LAMBDA_TASK_ROOT}/app/
COPY lambda_handler.py ${LAMBDA_TASK_ROOT}/

# Fix file permissions for Lambda runtime (do this in builder stage where find is available)
RUN chmod -R 755 ${LAMBDA_TASK_ROOT}/app && \
    chmod 644 ${LAMBDA_TASK_ROOT}/lambda_handler.py && \
    find ${LAMBDA_TASK_ROOT}/app -type f -name "*.py" -exec chmod 644 {} \;

# ============================================================================
# Stage 3: Final minimal runtime image
# ============================================================================
# Use the official public Lambda python base image and install required system
# dependencies here to avoid relying on a private pre-built base image.
FROM public.ecr.aws/lambda/python:3.12

# Set NLTK data path
ENV NLTK_DATA=${LAMBDA_TASK_ROOT}/nltk_data

# Install system packages required at runtime (mirrors items previously
# included in the private base image). This increases build time but ensures
# the image can be built on GitHub Actions without pulling a private image.
RUN dnf install -y \
    poppler-utils \
    poppler-data || true && \
    dnf install -y \
    cairo pango freetype harfbuzz fontconfig \
    mesa-libGL mesa-libGLU mesa-libgbm \
    libglvnd* libpng libjpeg-turbo libtiff openjpeg2 || true && \
    dnf install -y gcc gcc-c++ file-libs glib2 || true && \
    dnf clean all || true

# Copy everything from builder stage (permissions already fixed)
COPY --from=builder ${LAMBDA_TASK_ROOT} ${LAMBDA_TASK_ROOT}

# Set Lambda handler
CMD ["lambda_handler.handler"]